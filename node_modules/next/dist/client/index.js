"use strict";var _interopRequireWildcard3=require("@babel/runtime/helpers/interopRequireWildcard");var _interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault");exports.__esModule=true;exports.render=render;exports.renderError=renderError;exports.default=exports.emitter=exports.router=exports.version=void 0;var _extends2=_interopRequireDefault(require("@babel/runtime/helpers/extends"));var _interopRequireWildcard2=_interopRequireDefault(require("@babel/runtime/helpers/interopRequireWildcard"));var _router=require("next/router");var _querystring=require("querystring");var _react=_interopRequireDefault(require("react"));var _reactDom=_interopRequireDefault(require("react-dom"));var _headManagerContext=require("../next-server/lib/head-manager-context");var _mitt=_interopRequireDefault(require("../next-server/lib/mitt"));var _routerContext=require("../next-server/lib/router-context");var _isDynamic=require("../next-server/lib/router/utils/is-dynamic");var envConfig=_interopRequireWildcard3(require("../next-server/lib/runtime-config"));var _utils=require("../next-server/lib/utils");var _headManager=_interopRequireDefault(require("./head-manager"));var _pageLoader=_interopRequireDefault(require("./page-loader"));var _performanceRelayer=_interopRequireDefault(require("./performance-relayer"));/* global location */ /// <reference types="react-dom/experimental" />
if(!('finally'in Promise.prototype)){// eslint-disable-next-line no-extend-native
Promise.prototype.finally=require('next/dist/build/polyfills/finally-polyfill.min');}var data=JSON.parse(document.getElementById('__NEXT_DATA__').textContent);window.__NEXT_DATA__=data;var version="9.4.1";exports.version=version;var{props,err,page,query,buildId,assetPrefix,runtimeConfig,dynamicIds,isFallback}=data;var prefix=assetPrefix||'';// With dynamic assetPrefix it's no longer possible to set assetPrefix at the build time
// So, this is how we do it in the client side at runtime
__webpack_public_path__=prefix+"/_next/";//eslint-disable-line
// Initialize next/config with the environment configuration
envConfig.setConfig({serverRuntimeConfig:{},publicRuntimeConfig:runtimeConfig||{}});var asPath=(0,_utils.getURL)();var pageLoader=new _pageLoader.default(buildId,prefix);var register=(_ref)=>{var[r,f]=_ref;return pageLoader.registerPage(r,f);};if(window.__NEXT_P){window.__NEXT_P.map(register);}window.__NEXT_P=[];window.__NEXT_P.push=register;var updateHead=(0,_headManager.default)();var appElement=document.getElementById('__next');var lastAppProps;var webpackHMR;var router;exports.router=router;var ErrorComponent;var Component;var App,onPerfEntry;class Container extends _react.default.Component{componentDidCatch(err,info){this.props.fn(err,info);}componentDidMount(){this.scrollToHash();if(process.env.__NEXT_PLUGINS){// eslint-disable-next-line
Promise.resolve().then(()=>(0,_interopRequireWildcard2.default)(require('next-plugin-loader?middleware=unstable-post-hydration!'))).then(mod=>{return mod.default();}).catch(err=>{console.error('Error calling post-hydration for plugins',err);});}// We need to replace the router state if:
// - the page was (auto) exported and has a query string or search (hash)
// - it was auto exported and is a dynamic route (to provide params)
// - if it is a client-side skeleton (fallback render)
if(router.isSsr&&(isFallback||data.nextExport&&((0,_isDynamic.isDynamicRoute)(router.pathname)||location.search)||props&&props.__N_SSG&&location.search)){// update query on mount for exported pages
router.replace(router.pathname+'?'+(0,_querystring.stringify)((0,_extends2.default)((0,_extends2.default)({},router.query),(0,_querystring.parse)(location.search.substr(1)))),asPath,{// WARNING: `_h` is an internal option for handing Next.js
// client-side hydration. Your app should _never_ use this property.
// It may change at any time without notice.
_h:1,// Fallback pages must trigger the data fetch, so the transition is
// not shallow.
// Other pages (strictly updating query) happens shallowly, as data
// requirements would already be present.
shallow:!isFallback});}if(process.env.__NEXT_TEST_MODE){window.__NEXT_HYDRATED=true;if(window.__NEXT_HYDRATED_CB){window.__NEXT_HYDRATED_CB();}}}componentDidUpdate(){this.scrollToHash();}scrollToHash(){var{hash}=location;hash=hash&&hash.substring(1);if(!hash)return;var el=document.getElementById(hash);if(!el)return;// If we call scrollIntoView() in here without a setTimeout
// it won't scroll properly.
setTimeout(()=>el.scrollIntoView(),0);}render(){if(process.env.NODE_ENV==='production'){return this.props.children;}if(process.env.NODE_ENV!=='production'){var{ReactDevOverlay}=require('@next/react-dev-overlay/lib/client');return/*#__PURE__*/_react.default.createElement(ReactDevOverlay,null,this.props.children);}}}var emitter=(0,_mitt.default)();exports.emitter=emitter;var _default=async function _default(_temp){var{webpackHMR:passedWebpackHMR}=_temp===void 0?{}:_temp;// This makes sure this specific lines are removed in production
if(process.env.NODE_ENV==='development'){webpackHMR=passedWebpackHMR;}var{page:app,mod}=await pageLoader.loadPageScript('/_app');App=app;if(mod&&mod.reportWebVitals){onPerfEntry=(_ref2)=>{var{id,name,startTime,value,duration,entryType,entries}=_ref2;// Combines timestamp with random number for unique ID
var uniqueID=Date.now()+"-"+(Math.floor(Math.random()*(9e12-1))+1e12);var perfStartEntry;if(entries&&entries.length){perfStartEntry=entries[0].startTime;}mod.reportWebVitals({id:id||uniqueID,name,startTime:startTime||perfStartEntry,value:value==null?duration:value,label:entryType==='mark'||entryType==='measure'?'custom':'web-vital'});};}var initialErr=err;try{;({page:Component}=await pageLoader.loadPage(page));if(process.env.NODE_ENV!=='production'){var{isValidElementType}=require('react-is');if(!isValidElementType(Component)){throw new Error("The default export is not a React Component in page: \""+page+"\"");}}}catch(error){// This catches errors like throwing in the top level of a module
initialErr=error;}if(process.env.NODE_ENV==='development'){var{getNodeError}=require('@next/react-dev-overlay/lib/client');// Server-side runtime errors need to be re-thrown on the client-side so
// that the overlay is rendered.
if(initialErr){if(initialErr===err){setTimeout(()=>{var error;try{// Generate a new error object. We `throw` it because some browsers
// will set the `stack` when thrown, and we want to ensure ours is
// not overridden when we re-throw it below.
throw new Error(initialErr.message);}catch(e){error=e;}error.name=initialErr.name;error.stack=initialErr.stack;var node=getNodeError(error);throw node;});}// We replaced the server-side error with a client-side error, and should
// no longer rewrite the stack trace to a Node error.
else{setTimeout(()=>{throw initialErr;});}}}if(window.__NEXT_PRELOADREADY){await window.__NEXT_PRELOADREADY(dynamicIds);}exports.router=router=(0,_router.createRouter)(page,query,asPath,{initialProps:props,pageLoader,App,Component,wrapApp,err:initialErr,isFallback,subscription:(_ref3,App)=>{var{Component,props,err}=_ref3;render({App,Component,props,err});}});// call init-client middleware
if(process.env.__NEXT_PLUGINS){// eslint-disable-next-line
Promise.resolve().then(()=>(0,_interopRequireWildcard2.default)(require('next-plugin-loader?middleware=on-init-client!'))).then(mod=>{return mod.default({router});}).catch(err=>{console.error('Error calling client-init for plugins',err);});}var renderCtx={App,Component,props,err:initialErr};if(process.env.NODE_ENV==='production'){render(renderCtx);return emitter;}if(process.env.NODE_ENV!=='production'){return{emitter,render,renderCtx};}};exports.default=_default;async function render(props){if(props.err){await renderError(props);return;}try{await doRender(props);}catch(err){if(process.env.NODE_ENV==='development'){// Ensure this error is displayed in the overlay in development
setTimeout(()=>{throw err;});}await renderError((0,_extends2.default)((0,_extends2.default)({},props),{},{err}));}}// This method handles all runtime and debug errors.
// 404 and 500 errors are special kind of errors
// and they are still handle via the main render method.
function renderError(props){var{App,err}=props;// In development runtime errors are caught by our overlay
// In production we catch runtime errors using componentDidCatch which will trigger renderError
if(process.env.NODE_ENV!=='production'){// A Next.js rendering runtime error is always unrecoverable
// FIXME: let's make this recoverable (error in GIP client-transition)
webpackHMR.onUnrecoverableError();// We need to render an empty <App> so that the `<ReactDevOverlay>` can
// render itself.
return doRender({App:()=>null,props:{},Component:()=>null,err:null});}if(process.env.__NEXT_PLUGINS){// eslint-disable-next-line
Promise.resolve().then(()=>(0,_interopRequireWildcard2.default)(require('next-plugin-loader?middleware=on-error-client!'))).then(mod=>{return mod.default({err});}).catch(err=>{console.error('error calling on-error-client for plugins',err);});}// Make sure we log the error to the console, otherwise users can't track down issues.
console.error(err);return pageLoader.loadPage('/_error').then((_ref4)=>{var{page:ErrorComponent}=_ref4;// In production we do a normal render with the `ErrorComponent` as component.
// If we've gotten here upon initial render, we can use the props from the server.
// Otherwise, we need to call `getInitialProps` on `App` before mounting.
var AppTree=wrapApp(App);var appCtx={Component:ErrorComponent,AppTree,router,ctx:{err,pathname:page,query,asPath,AppTree}};return Promise.resolve(props.props?props.props:(0,_utils.loadGetInitialProps)(App,appCtx)).then(initProps=>doRender((0,_extends2.default)((0,_extends2.default)({},props),{},{err,Component:ErrorComponent,props:initProps})));});}// If hydrate does not exist, eg in preact.
var isInitialRender=typeof _reactDom.default.hydrate==='function';var reactRoot=null;function renderReactElement(reactEl,domEl){if(process.env.__NEXT_REACT_MODE!=='legacy'){if(!reactRoot){var opts={hydrate:true};reactRoot=process.env.__NEXT_REACT_MODE==='concurrent'?_reactDom.default.unstable_createRoot(domEl,opts):_reactDom.default.unstable_createBlockingRoot(domEl,opts);}reactRoot.render(reactEl);}else{// mark start of hydrate/render
if(_utils.ST){performance.mark('beforeRender');}// The check for `.hydrate` is there to support React alternatives like preact
if(isInitialRender){_reactDom.default.hydrate(reactEl,domEl,markHydrateComplete);isInitialRender=false;if(onPerfEntry&&_utils.ST){(0,_performanceRelayer.default)(onPerfEntry);}}else{_reactDom.default.render(reactEl,domEl,markRenderComplete);}}}function markHydrateComplete(){if(!_utils.ST)return;performance.mark('afterHydrate');// mark end of hydration
performance.measure('Next.js-before-hydration','navigationStart','beforeRender');performance.measure('Next.js-hydration','beforeRender','afterHydrate');if(onPerfEntry){performance.getEntriesByName('Next.js-hydration').forEach(onPerfEntry);}clearMarks();}function markRenderComplete(){if(!_utils.ST)return;performance.mark('afterRender');// mark end of render
var navStartEntries=performance.getEntriesByName('routeChange','mark');if(!navStartEntries.length){return;}performance.measure('Next.js-route-change-to-render',navStartEntries[0].name,'beforeRender');performance.measure('Next.js-render','beforeRender','afterRender');if(onPerfEntry){performance.getEntriesByName('Next.js-render').forEach(onPerfEntry);performance.getEntriesByName('Next.js-route-change-to-render').forEach(onPerfEntry);}clearMarks();['Next.js-route-change-to-render','Next.js-render'].forEach(measure=>performance.clearMeasures(measure));}function clearMarks(){;['beforeRender','afterHydrate','afterRender','routeChange'].forEach(mark=>performance.clearMarks(mark));}function AppContainer(_ref5){var{children}=_ref5;return/*#__PURE__*/_react.default.createElement(Container,{fn:error=>renderError({App,err:error}).catch(err=>console.error('Error rendering page: ',err))},/*#__PURE__*/_react.default.createElement(_routerContext.RouterContext.Provider,{value:(0,_router.makePublicRouterInstance)(router)},/*#__PURE__*/_react.default.createElement(_headManagerContext.HeadManagerContext.Provider,{value:updateHead},children)));}var wrapApp=App=>props=>{var appProps=(0,_extends2.default)((0,_extends2.default)({},props),{},{Component,err,router});return/*#__PURE__*/_react.default.createElement(AppContainer,null,/*#__PURE__*/_react.default.createElement(App,appProps));};async function doRender(_ref6){var{App,Component,props,err}=_ref6;// Usual getInitialProps fetching is handled in next/router
// this is for when ErrorComponent gets replaced by Component by HMR
if(!props&&Component&&Component!==ErrorComponent&&lastAppProps.Component===ErrorComponent){var{pathname,query:_query,asPath:_asPath}=router;var AppTree=wrapApp(App);var appCtx={router,AppTree,Component:ErrorComponent,ctx:{err,pathname,query:_query,asPath:_asPath,AppTree}};props=await(0,_utils.loadGetInitialProps)(App,appCtx);}Component=Component||lastAppProps.Component;props=props||lastAppProps.props;var appProps=(0,_extends2.default)((0,_extends2.default)({},props),{},{Component,err,router});// lastAppProps has to be set before ReactDom.render to account for ReactDom throwing an error.
lastAppProps=appProps;emitter.emit('before-reactdom-render',{Component,ErrorComponent,appProps});var elem=/*#__PURE__*/_react.default.createElement(AppContainer,null,/*#__PURE__*/_react.default.createElement(App,appProps));// We catch runtime errors using componentDidCatch which will trigger renderError
renderReactElement(process.env.__NEXT_STRICT_MODE?/*#__PURE__*/_react.default.createElement(_react.default.StrictMode,null,elem):elem,appElement);emitter.emit('after-reactdom-render',{Component,ErrorComponent,appProps});}